import org.xml.sax.Attributes
import org.xml.sax.SAXException
import org.xml.sax.helpers.DefaultHandler

import javax.xml.parsers.ParserConfigurationException
import javax.xml.parsers.SAXParser
import javax.xml.parsers.SAXParserFactory
import java.util.jar.JarEntry
import java.util.jar.JarOutputStream
import java.util.regex.Pattern
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

configurations {
    innerPlugin
}

def innerPluginApkList = []

class FaiyExt {
    private String pluginProcess = ":plugin"

    public String getPluginProcess() {
        return pluginProcess
    }

    public void setPluginProcess(String process) {
        this.pluginProcess = process
    }
}
extensions.create('fairy', FaiyExt)

if ("false".equals(rootProject.properties.get("android.enableAapt2"))) {
    throw new Exception("请开启aapt2编译开关：android.enableAapt2")
}

//generateSourcess时借此文件生成attrs.xml
android.aaptOptions.additionalParameters("--emit-ids", project.buildDir.absolutePath + "/outputs/generated_exported_all_resouces.properties")

afterEvaluate {

    if (android.defaultConfig.applicationId == null) {
        throw new Exception("宿主build.gradle未配置android.defaultConfig.applicationId")
    }

    //收集需要内置的插件文件地址
    configurations.innerPlugin.files.each { file ->
        innerPluginApkList << file.absolutePath
    }

    for (variant in android.applicationVariants) {

        def varName = variant.name;
        def buildTypeName = variant.buildType.name
        def flavorName = variant.flavorName
        def varDirName =  variant.dirName

        println 'Check Env : variant=' + varName +  ", buildTypeName=" + buildTypeName + ", flavorName=" + flavorName + ", varDirName=" + varDirName

        def mergeAssetsTask = variant.getMergeAssets()
        mergeAssetsTask.setOnlyIf { true }
        mergeAssetsTask.outputs.upToDateWhen { false }
        mergeAssetsTask.doLast {

            //检查内置插件坐标是否存在，不存在给出提示
            innerPluginApkList.each { innerAPK ->
                if (!file(innerAPK).exists()) {
                    project.logger.info "引用的插件apk文件不存在，可能插件apk还未编译完成，或者宿主innerPlugin配置的路径错误：", innerAPK
                }
            }

            copy {
                project.logger.error '复制宿主依赖的内置插件到merge后的assets目录\n' + innerPluginApkList + "\n" + outputDir
                from files(innerPluginApkList)
                into(outputDir)
            }
        }

        tasks.findByName("process${varName.capitalize()}Manifest").doLast {
            fileTree(manifestOutputDirectory).include("**/AndroidManifest.xml").each { manifestFile->
                println '正在检查Manifest中的插件配置是否正确' + manifestFile.absolutePath

                def originManifestContent = manifestFile.getText('UTF-8')
                if (originManifestContent.contains("{applicationId}")) {
                    throw new Exception("宿主build.gradle未配置android.defaultConfig.applicationId")
                }

                //生成prop文件
                def pattern = Pattern.compile("versionName\\s*=\\s*\"(.+?)\"");
                def matcher = pattern.matcher(originManifestContent);
                if (matcher.find()) {
                    def versionName = matcher.group(1)
                    //File hostInfo = new File("${project.buildDir}/outputs/HostInfo-" + tastName.replace("process","").replace("Resources", "") + ".prop")
                    //没有单独命名，有多个favor时文件会覆盖
                    File hostInfo = new File("${project.buildDir}/outputs/HostInfo.prop")
                    if (hostInfo.exists()) {
                        hostInfo.delete()
                    }
                    //没有单独命名，有多个abi时文件会覆盖
                    println '正在生成文件' + hostInfo.absolutePath
                    hostInfo.write("#Host Manifest CREATED AT " + new Date().format("yyyy-MM-dd HH:mm::ss"))
                    hostInfo.append("\nhost.versionCode=" + android.defaultConfig.versionCode)
                    //versionName可能有后缀，所以以Manifest中为准
                    hostInfo.append("\nhost.versionName=" + versionName)
                    hostInfo.append("\nhost.buildType=" + buildTypeName)
                    hostInfo.append("\nhost.flavorName=" + flavorName)
                    hostInfo.append("\nhost.varName=" + varName)
                    hostInfo.append("\nhost.varDirName=" + varDirName)
                    def packageName = android.defaultConfig.applicationId
                    if (android.buildTypes[buildTypeName].applicationIdSuffix != null) {
                        packageName = packageName + android.buildTypes[buildTypeName].applicationIdSuffix;
                    }

                    hostInfo.append("\nhost.applicationId=" + packageName)
                }

                //指定插件进程名，设置为空串或者null即是和宿主同进程
                //不设置即使用默认进程(:plugin)
                def pluginProcessName = fairy.pluginProcess
                if (!":plugin".equals(pluginProcessName)) {
                    def customPluginProcessName = "";
                    if (pluginProcessName != null) {
                        customPluginProcessName = "android:process=\"" + pluginProcessName + "\""
                    }
                    println '正在设置插件进程配置：' + customPluginProcessName
                    def modifyedManifestContent = originManifestContent.replaceAll("android:process=\":plugin\"", customPluginProcessName)
                    manifestFile.write(modifyedManifestContent, 'UTF-8')
                }
            }
        }

        tasks.findByName("process${varName.capitalize()}Resources").doLast {
            //实际上最新版sdk和gradle可以直接指定apk了, 可以不使用.ap_文件
            //def processResFullName = baseVariant.apkData.fullName
            copy {
                project.logger.error name + ' 编译宿主资源编译完成后导出后缀为.ap_的资源包，此资源包在编译非独立插件时需要此包'
                println "from :" + resPackageOutputFolder
                from resPackageOutputFolder
                include("*.ap_")
                into("${project.buildDir}/outputs/")
                rename(new Transformer<String, String>() {
                    @Override
                    String transform(String s) {
                        //多abi时会相互覆盖，不过对我们而言应该没什么影响
                        project.logger.error "rename: " + s
                        return "resources.ap_"
                    }
                })
            }
        }

        //将宿主的所有class，包括宿主的、和它所有依赖的类，合并起来打出一个jar来，供将来的非独立插件使用
        def org.gradle.api.tasks.compile.JavaCompile javaCompile = variant.javaCompile;
        javaCompile.doLast {

            println "Merge Jar After Task " + name + " buildType is " + buildTypeName + ", flavorName is " + flavorName +  ", varName is " + varName

            File jarFile = new File(project.buildDir, "outputs/host_classes.jar")
            if (jarFile.exists()) {
                jarFile.delete()
            }

            JarMerger jarMerger = new JarMerger(jarFile)
            try {
                jarMerger.setFilter(new JarFilter() {
                    public boolean checkEntry(String archivePath) throws JarFilter.ZipAbortException {
                        if (archivePath.endsWith(".class")) {
                            return true
                        }
                        return false
                    }
                });

                classpath.each { jarPath ->
                    println "adding jar " + jarPath
                    jarMerger.addJar(jarPath);
                    //jarMerger.addFolder(directoryInput.getFile());
                }

                def buildClassesTaskName = "packageAppClasses" + varName.capitalize();
                def classesPath= 'intermediates/app_classes/' + varName + "/" + buildClassesTaskName + "/classes.jar"

                if (!tasks.findByName(buildClassesTaskName)) {
                    throw new IllegalAccessError("未找到打包宿主classes的task，请检查android gradle 插件版本")
                }

                File classes = new File(buildDir, classesPath);

                if (!classes.exists()) {
                    try {
                        tasks.getByName(buildClassesTaskName).execute()
                    } catch(Exception e) {
                        projects.logger.log(LogLevel.ERROR, "fail to create jar for task " + name + " " + buildClassesTaskName)
                    }
                } else {
                    projects.logger.log(LogLevel.DEBUG, "classes path already exists： " + classes.absolutePath)
                }
                if (classes.exists()) {
                    println "adding jar " + classes
                    jarMerger.addJar(classes)
                } else {
                    projects.logger.log(LogLevel.ERROR, "Not exists : classes file path is " + classes.absolutePath)
                    projects.logger.log(LogLevel.ERROR, "Not exists : build classes task name is " + buildClassesTaskName)
                }
            } finally {
                jarMerger.close()
            }

            println "Merge Jar Finished, Jar is at " + jarFile.absolutePath
        }

        //处理混淆，这里保存混淆以后dex之前的jar包作为基线包备用
        def proguardTask = project.tasks.findByName("transformClassesAndResourcesWithProguardFor${variant.name.capitalize()}")
        if (proguardTask) {
            proguardTask.doFirst {
                println "开始混淆任务：" + varName.capitalize()
            }
            proguardTask.doLast {
                println "混淆完成：" + varName.capitalize()
                boolean isFind = false;
                proguardTask.outputs.files.files.each { File file->
                    //http://blog.csdn.net/sbsujjbcy/article/details/50839263
                    //build/intermediates/transforms/proguard/anzhi/release/jars/3/1f/main.jar
                    //最新版本路径已发生变化；2017-11-12
                    project.logger.error "file outputs=>${file.absolutePath}"
                    String keyword = File.separator + "transforms" + File.separator + "proguard" + File.separator;
                    println String.valueOf(file.absolutePath.contains(keyword)) + ", " + String.valueOf(file.absolutePath.endsWith(buildTypeName))
                    if (file.absolutePath.contains(keyword) && file.absolutePath.endsWith(buildTypeName)) {

                        isFind = true;
                        def sourceHostObfuscatedJar
                        if (new File(file.absolutePath + "/0.jar").exists()) {
                            sourceHostObfuscatedJar = file.absolutePath + "/0.jar"
                        } else if (new File(file.absolutePath + "/jars/3/1f/main.jar").exists()) {
                            sourceHostObfuscatedJar = file.absolutePath + "/jars/3/1f/main.jar"
                        }
                        def hostObfuscatedJar = "host_obfuscated.jar"
                        project.logger.error "导出混淆后的宿主jar " + sourceHostObfuscatedJar + " 包到 " + "${project.buildDir}/outputs/" + hostObfuscatedJar

                        copy {
                            from sourceHostObfuscatedJar
                            into("${project.buildDir}/outputs/")
                            rename(new Transformer<String, String>() {
                                @Override
                                String transform(String s) {
                                    project.logger.error "rename:" + s
                                    return hostObfuscatedJar
                                }
                            })
                        }
                    }
                }
                if (!isFind) {
                    throw "obfuscated jar file not found, please check."
                }
            }
        }

        //导出宿主最终的基线包
        tasks.findByName("assemble${varName.capitalize()}").finalizedBy makeHostBaseLine
    }

    if (gradle.startParameter.taskNames.find {
        println ">>>>>>执行命令: " + it
        it.startsWith("assemble") || it.startsWith("build")
    } != null) {
        //nothing
    }
}

//将宿主编译产物作为基线包存档，这样可以使插件脱离宿主工程独立编译
task makeHostBaseLine(type: Zip) {
    extension "bar" //Baseline Application Resource
    baseName 'host'
    from zipTree("build/outputs/resources.ap_")
    from('build/outputs') {
        exclude '*.ap_'
    }
}

public class JarMerger {
    private final byte[] buffer = new byte[8192];
    private final File jarFile;
    private FileOutputStream fos;
    private JarOutputStream jarOutputStream;

    private JarFilter filter;

    public JarMerger(File jarFile) throws IOException {
        this.jarFile = jarFile;
    }

    private void init() throws IOException {
        if(this.fos == null && this.jarOutputStream == null) {
            if(!this.jarFile.getParentFile().mkdirs() && !this.jarFile.getParentFile().exists()) {
                throw new RuntimeException("Cannot create directory " + this.jarFile.getParentFile());
            }
            this.fos = new FileOutputStream(this.jarFile);
            this.jarOutputStream = new JarOutputStream(fos);
        }
    }

    public void setFilter(JarFilter filter) {
        this.filter = filter;
    }

    public void addFolder(File folder) throws IOException {
        this.init();

        try {
            this.addFolderInternal(folder, "");
        } catch (JarFilter.ZipAbortException var3) {
            throw new IOException(var3);
        }
    }

    private void addFolderInternal(File folder, String path) throws IOException, JarFilter.ZipAbortException {
        File[] files = folder.listFiles();
        if(files != null) {
            File[] arr$ = files;
            int len$ = files.length;

            for(int i$ = 0; i$ < len$; ++i$) {
                File file = arr$[i$];
                if(!file.isFile()) {
                    if(file.isDirectory()) {
                        this.addFolderInternal(file, path + file.getName() + "/");
                    }
                } else {
                    String entryPath = path + file.getName();
                    if(this.filter == null || this.filter.checkEntry(entryPath)) {
                        this.jarOutputStream.putNextEntry(new JarEntry(entryPath));
                        FileInputStream fis = null;
                        try {
                            fis = new FileInputStream(file);

                            int count;
                            while((count = fis.read(this.buffer)) != -1) {
                                this.jarOutputStream.write(this.buffer, 0, count);
                            }
                        } finally {
                            if (fis != null) {
                                fis.close();
                                fis = null;
                            }
                        }

                        this.jarOutputStream.closeEntry();
                    }
                }
            }
        }

    }

    public void addJar(File file) throws IOException {
        this.addJar(file, false);
    }

    public void addJar(File file, boolean removeEntryTimestamp) throws IOException {
        this.init();

        FileInputStream e = null;
        ZipInputStream zis = null;
        try {
            e = new FileInputStream(file);
            zis = new ZipInputStream(e);

            ZipEntry entry;
            while((entry = zis.getNextEntry()) != null) {
                if(!entry.isDirectory()) {
                    String name = entry.getName();
                    if(this.filter == null || this.filter.checkEntry(name)) {
                        JarEntry newEntry;
                        if(entry.getMethod() == ZipEntry.STORED) {
                            newEntry = new JarEntry(entry);
                        } else {
                            newEntry = new JarEntry(name);
                        }

                        if(removeEntryTimestamp) {
                            newEntry.setTime(0L);
                        }

                        this.jarOutputStream.putNextEntry(newEntry);

                        int count;
                        while((count = zis.read(this.buffer)) != -1) {
                            this.jarOutputStream.write(this.buffer, 0, count);
                        }

                        this.jarOutputStream.closeEntry();
                        zis.closeEntry();
                    }
                }
            }
        } catch (JarFilter.ZipAbortException var13) {
            throw new IOException(var13);
        } finally {
            if (zis != null) {
                zis.close();
            }
            if (e != null) {
                e.close();
            }
        }

    }

    public void addEntry(String path, byte[] bytes) throws IOException {
        this.init();
        this.jarOutputStream.putNextEntry(new JarEntry(path));
        this.jarOutputStream.write(bytes);
        this.jarOutputStream.closeEntry();
    }

    public void close() throws IOException {
        if (this.jarOutputStream != null) {
            jarOutputStream.close();
            jarOutputStream = null;
        }
        if (this.fos != null) {
            fos.close();
            fos = null;
        }

    }
}

public interface JarFilter {
    boolean checkEntry(String var1) throws ZipAbortException;

    public static class ZipAbortException extends Exception {
        private static final long serialVersionUID = 1L;

        public ZipAbortException() {
        }

        public ZipAbortException(String format, Object... args) {
            super(String.format(format, args));
        }

        public ZipAbortException(Throwable cause, String format, Object... args) {
            super(String.format(format, args), cause);
        }

        public ZipAbortException(Throwable cause) {
            super(cause);
        }
    }
}